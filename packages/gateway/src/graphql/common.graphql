# automatically map from FHIR

scalar Date

input HumanNameInput {
  use: String # traditional (Bangla) or English
  givenName: String
  familyName: String
}

type HumanName { # -> HumanName
  use: String # traditional (Bangla) or English
  givenName: String # -> .given
  familyName: String # -> .family
}

enum Relationship {
  GUARDIAN
  NON_LEGAL_GUARDIAN
  MATERNAL_GRANDMOTHER
  MATERNAL_GRANDFATHER
  PATERNAL_GRANDMOTHER
  PATERNAL_GRANDFATHER
}

enum LocationType {
  HOSPITAL
  OTHER_INSTITUTION
  PRIVATE_HOME
  OTHER
}

enum IdentityIDType {
  PASSPORT
  NATIONAL_ID
  DRIVING_LICENCE
  BIRTH_REGISTRATION_NUMBER
  DEATH_REGISTRATION_NUMBER
  REFUGEE_NUMBER
  ALIEN_NUMBER
}

enum EducationType {
  NO_SCHOOLING
  PRIMARY_ISCED_1
  LOWER_SECONDARY_ISCED_2
  UPPER_SECONDARY_ISCED_3
  POST_SECONDARY_ISCED_4
  FIRST_STAGE_TERTIARY_ISCED_5
  SECOND_STAGE_TERTIARY_ISCED_6
  NOT_STATED
}

enum MaritalStatusType {
  SINGLE
  MARRIED
  WIDOWED
  DIVORCED
  NOT_STATED
}

enum AddressType {
  CURRENT
  PERMANENT
  MILITARY_BASE_OR_CANTONMENT
  IDP_CAMP # -> Disaster Camp
  UNHCR_CAMP # -> UNHCR Camp
}

input IdentityInput {
  id: ID
  type: IdentityIDType
}

type IdentityType { # -> Identifier
  id: ID # -> .value
  type: IdentityIDType # -> .system
}

input PersonInput {
  identifier: [IdentityInput]
  name: [HumanNameInput]
  telecom: [ContactPointInput]
  gender: String
  birthDate: String
  maritalStatus: MaritalStatusType
  dateOfMarriage: Date
  # For order of birth 3 equals 3rd born
  multipleBirth: Int
  address: [AddressInput]
  photo: AttachmentInput
  deceased: Boolean
  nationality: [String]
  educationalAttainment: EducationType
}

type Person { # -> Patient
  id: ID
  identifier: [IdentityType] # -> .identifier
  name: [HumanName] # -> .name
  telecom: [ContactPoint] # -> .telecom
  gender: String # -> .gender
  birthDate: String # -> birthDate
  maritalStatus: MaritalStatusType # -> .maritalStatus
  dateOfMarriage: Date # -> .extension(url='http://opencrvs.org/specs/date-of-marriage').valueDateTime
  # For order of birth 3 equals 3rd born
  multipleBirth: Int # -> .multipleBirthInteger
  address: [Address] # -> .address
  photo: Attachment # -> .photo
  deceased: Boolean # -> .deceasedBoolean
  nationality: [String] # -> .extension https://www.hl7.org/fhir/extension-patient-nationality.html
  educationalAttainment: EducationType # -> .extension(url='http://opencrvs.org/specs/extension/educational-attainment').valueString
}

input ContactPointInput {
  # phone | fax | email | pager | url | sms | other
  system: String
  # The actual contact point details
  value: String
  # home | work | temp | old | mobile - purpose of this contact point
  use: String
}

type ContactPoint { # -> ContactPoint
  # phone | fax | email | pager | url | sms | other
  system: String # -> .system
  # The actual contact point details
  value: String # -> .value
  # home | work | temp | old | mobile - purpose of this contact point
  use: String # -> .use
}

input LocationInput {
  identifier: [ID]
  status: String
  name: String
  alias: [String]
  description: String
  type: LocationType
  telecom: [ContactPointInput]
  address: AddressInput
  longitude: Float
  latitude: Float
  altitude: Float
}

type Location { # -> Location (mostly the same property name except:)
  id: ID!
  identifier: [ID]
  status: String
  name: String
  alias: [String]
  description: String
  type: LocationType
  telecom: [ContactPoint]
  address: Address
  longitude: Float # -> position.longitude
  latitude: Float # -> position.latitude
  altitude: Float # -> position.altitude
}

input AddressInput {
  use: String
  type: AddressType
  text: String # Reserve for geo-code
  line: [String]
  city: String
  district: String
  state: String
  postalCode: String
  country: String
  from: Date
  to: Date
}

type Address { # -> Address (mostly the same property name except:)
  use: String
  type: AddressType
  text: String # Reserve for geo-code
  line: [String]
  city: String
  district: String
  state: String
  postalCode: String
  country: String
  from: Date # -> .period.start
  to: Date # -> .period.end
}

# TODO: Move to user feature when built out - manage through a user management microservice
input UserInput {
  userName: String
  created: Date
  lastLoggedIn: Date
  firstName: String
  lastName: String
  telecom: [ContactPointInput]
  identifier: [IdentityInput]
  role: [UserRoleInput]!
  address: AddressInput
  primaryOffice: LocationInput
  currentLocation: LocationInput
  catchmentArea: [LocationInput]
}

type User {
  id: ID!
  userName: String
  created: Date
  lastLoggedIn: Date
  firstName: String
  lastName: String
  telecom: [ContactPoint]
  identifier: [IdentityType]
  role: [UserRole]!
  address: Address
  primaryOffice: Location
  currentLocation: Location
  catchmentArea: [Location]
}

input UserRoleInput {
  type: String #declaration-clerk, registrar, certification-clerk, manager, admin
}

type UserRole {
  id: ID!
  type: String #declaration-clerk, registrar, certification-clerk, manager, admin
}

type Query {
  user(id: ID!): User
}
