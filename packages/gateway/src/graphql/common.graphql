# automatically map from FHIR

scalar Date

input HumanNameInput {
  use: String # traditional (Bangla) or English
  givenName: String
  familyName: String
}

type HumanName { # -> HumanName
  use: String # traditional (Bangla) or English
  givenName: String # -> .given
  familyName: String # -> .family
}

enum Relationship {
  GUARDIAN
  MATERNAL_GRANDMOTHER
  MATERNAL_GRANDFATHER
  PATERNAL_GRANDMOTHER
  PATERNAL_GRANDFATHER
  OTHER
}

enum LocationType {
  HOSPITAL
  OTHER_INSTITUTION
  PRIVATE_HOME
  OTHER
}

enum IdentityIDType {
  PASSPORT
  NATIONAL_ID
  DRIVING_LICENCE
  BIRTH_REGISTRATION_NUMBER
  DEATH_REGISTRATION_NUMBER
}

enum EducationType {
  NO_SCHOOLING
  PRIMARY_ISCED_1
  LOWER_SECONDARY_ISCED_2
  UPPER_SECONDARY_ISCED_3
  POST_SECONDARY_ISCED_4
  FIRST_STAGE_TERTIARY_ISCED_5
  SECOND_STAGE_TERTIARY_ISCED_6
  NOT_STATED
}

enum MigrantType {
  FOREIGN_RESIDENT
  STUDENT
  ASYLUM_SEEKER
  RESIDENT
  VISITOR
  TRANSIENT
  REFUGEE
  OTHER
}

enum MaritalStatusType {
  SINGLE
  LAWFULLY_MARRIED
  OTHER_UNIONS
  WIDOWED
  DIVORCED
  SEPARATED
  NOT_STATED
}

input IdentityInput { # -> Identifier
  id: ID # -> .value
  type: IdentityIDType # -> .system
}

type IdentityType { # -> Identifier
  id: ID # -> .value
  type: IdentityIDType # -> .system
}

input PersonInput {
  identifier: [IdentityInput]
  name: [HumanNameInput]
  telecom: [ContactPointInput]
  gender: String
  weightAtBirth: String
  birthDate: String
  maritalStatus: MaritalStatusType
  dateOfMarriage: Date
  # For order of birth 3 equals 3rd born
  multipleBirth: Int
  address: [AddressInput]
  photo: AttachmentInput
  deceased: Boolean
  nationality: String
  educationalAttainment: EducationType
  migrantStatus: MigrantType
}

type Person { # -> Patient
  id: ID
  identifier: [IdentityType] # -> .identifier
  name: [HumanName] # -> .name
  telecom: [ContactPoint] # -> .telecom
  gender: String # -> .gender
  weightAtBirth: String # Should this be Observation > Category > vital-signs > weight? # -> Observation.valueQuantity (code=kg)
  birthDate: String # -> birthDate
  maritalStatus: MaritalStatusType # -> .maritalStatus
  dateOfMarriage: Date # -> .extension custom
  # For order of birth 3 equals 3rd born
  multipleBirth: Int # -> .multipleBirth[x]
  address: [Address] # -> .address
  photo: Attachment # -> .photo
  deceased: Boolean # -> .deceased[x]
  nationality: String # -> .extension https://www.hl7.org/fhir/extension-patient-nationality.html
  educationalAttainment: EducationType # -> .extension custom
  migrantStatus: MigrantType # -> .extension custom
}

input RelatedPersonInput {
  identifier: [IdentityInput]
  name: [HumanNameInput]
  relationship: Relationship
  telecom: [ContactPointInput]
  gender: String
  birthDate: String
  address: [AddressInput]
  photo: AttachmentInput
  nationality: String # use https://www.hl7.org/fhir/extension-patient-nationality.html
}

# Only used for storing relationship, Patient is used for details
type RelatedPerson { # -> RelatedPerson
  id: ID # -> .id
  relationship: Relationship # -> .relationship.coding.code
  patient: Person # -> .patient.reference
}

input ContactPointInput {
  # phone | fax | email | pager | url | sms | other
  system: String
  # The actual contact point details
  value: String
  # home | work | temp | old | mobile - purpose of this contact point
  use: String
}

type ContactPoint { # -> ContactPoint
  # phone | fax | email | pager | url | sms | other
  system: String # -> .system
  # The actual contact point details
  value: String # -> .value
  # home | work | temp | old | mobile - purpose of this contact point
  use: String # -> .use
}

input LocationInput {
  identifier: [ID]
  status: String
  name: String
  alias: [String]
  description: String
  type: LocationType
  telecom: [ContactPointInput]
  address: AddressInput
  longitude: Float
  latitude: Float
  altitude: Float
}

type Location { # -> Location (mostly the same properties)
  id: ID!
  identifier: [ID]
  status: String
  name: String
  alias: [String]
  description: String
  type: LocationType
  telecom: [ContactPoint]
  address: Address
  longitude: Float # -> position.longitude
  latitude: Float # -> position.latitude
  altitude: Float # -> position.altitude
}

input AddressInput {
  use: String
  type: String
  text: String
  line: [String]
  city: String
  district: String
  state: String
  postalCode: String
  country: String
  from: Date
  to: Date
}

type Address { # -> Address
  use: String
  type: String
  text: String
  line: [String]
  city: String
  district: String
  state: String
  postalCode: String
  country: String
  from: Date # -> .period.start
  to: Date # -> .period.end
}

# TODO: Move to user feature when built out - manage through a user management microservice
input UserInput {
  userName: String
  created: Date
  lastLoggedIn: Date
  firstName: String
  lastName: String
  telecom: [ContactPointInput]
  identifier: [IdentityInput]
  role: [UserRoleInput]!
  address: AddressInput
  primaryOffice: LocationInput
  currentLocation: LocationInput
  catchmentArea: [LocationInput]
}

type User {
  id: ID!
  userName: String
  created: Date
  lastLoggedIn: Date
  firstName: String
  lastName: String
  telecom: [ContactPoint]
  identifier: [IdentityType]
  role: [UserRole]!
  address: Address
  primaryOffice: Location
  currentLocation: Location
  catchmentArea: [Location]
}

input UserRoleInput {
  type: String #declaration-clerk, registrar, certification-clerk, manager, admin
}

type UserRole {
  id: ID!
  type: String #declaration-clerk, registrar, certification-clerk, manager, admin
}

type Query {
  user(id: ID!): User
}
